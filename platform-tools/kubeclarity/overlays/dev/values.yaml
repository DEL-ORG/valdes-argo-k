# platform-tools/kubeclarity/overlays/dev/values.yaml
global:
  imagePullSecrets: []
  labels: {}
  annotations: {}

# Ensure the chart DOES NOT deploy the Bitnami postgres subchart
postgresql:
  enabled: false

backend:
  enabled: true
  replicaCount: 1
  image:
    repository: ghcr.io/openclarity/kubeclarity-backend
    tag: "v2.23.3"
    pullPolicy: IfNotPresent
  resources:
    requests:
      cpu: 100m
      memory: 256Mi
    limits:
      cpu: 500m
      memory: 512Mi
  persistence:
    enabled: false

ui:
  enabled: true
  replicaCount: 1
  image:
    repository: ghcr.io/openclarity/kubeclarity-ui
    tag: "v2.23.3"
    pullPolicy: IfNotPresent
  service:
    type: ClusterIP
    port: 8080

# Use an external DB (in-cluster service) instead of the chart's bundled Postgres
db:
  external:
    enabled: true
    host: kubeclarity-postgres        # service we'll create in-cluster
    port: 5432
    user: kubeclarity                # DB username (must match secret)
    database: kubeclarity
    # Password is read from a Kubernetes Secret (do NOT put the password here)
    passwordSecret:
      name: kubeclarity-db-secret
      key: POSTGRES_PASSWORD
    # If the chart supports specifying a username secret/key you can do similar,
    # otherwise the username above will be used as plain value.

ingress:
  enabled: false
  hosts: []
  annotations: {}

scanners:
  trivy:
    enabled: true
    image:
      repository: ghcr.io/aquasecurity/trivy
      tag: "0.44.0"
  grype:
    enabled: true
    image:
      repository: ghcr.io/anchore/grype
      tag: "0.71.0"

runtime:
  scanInterval: "24h"
  enableRuntimeScan: false

security:
  rbac:
    create: true

nodeSelector: {}
tolerations: []
affinity: {}

serviceAccount:
  create: true
  name: kubeclarity-sa

features:
  sbomGeneration: true
  vulnerabilityScanning: true
  runtimeScanning: false

prometheus:
  enabled: false

imagePullSecrets: []
